package main

import (
	"bytes"
	"context"
	"flag"
	"fmt"
	"go/ast"
	"go/token"
	"log/slog"
	"os"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

const clientTemplate = `
// Code generated by rpc client generator. DO NOT EDIT.

package {{.PackageName}}

{{if .Methods}}
func init() {
{{range .Methods}}
   gob.Register({{.ResponseType}}{})
   gob.Register({{.RequestType}}{})
{{end}}
}
{{end}}

var _ {{.ServiceName}} = (*{{.ServiceName}}Client)(nil)

type {{.ServiceName}}Client struct {
   client *rpc.Client
}

func New{{.ServiceName}}Client(address string) (*{{.ServiceName}}Client, error) {
   client, err := rpc.Dial("tcp", address)
   if err != nil {
       return nil, fmt.Errorf("{{$.PackageName}}.New{{.ServiceName}}Client rpc.Dial error: %w", err)
   }

   return &{{.ServiceName}}Client{client: client}, nil
}

{{range .Methods}}
func (c *{{$.ServiceName}}Client) {{.Name}}(request *{{.RequestType}}, response *{{.ResponseType}}) error {
   err := c.client.Call("{{$.ServiceName}}.{{.Name}}", request, response)
   if err != nil {
       return fmt.Errorf("{{$.PackageName}}.{{$.ServiceName}}Client.{{.Name}} Call error: %w", err)
   }

   return nil
}
{{end}}

func (c *{{.ServiceName}}Client) Close() error {
   return c.client.Close()
}
`

type Method struct {
	Name         string
	RequestType  string
	ResponseType string
}

type ServiceData struct {
	PackageName string
	ServiceName string
	Methods     []Method
}

var (
	input   = flag.String("input", "./...", "Input Go package directory (required)")
	verbose = flag.Bool("verbose", false, "Enable verbose logging")
)

func log(level slog.Level, format string, args ...any) {
	if *verbose {
		slog.Log(context.Background(), level, format, args...)
	}
}

func extractTypeName(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		return "*" + extractTypeName(t.X)
	default:
		return "unknown"
	}
}

func validateMethodSignature(fset *token.FileSet, fileName, serviceName, methodName string, funcType *ast.FuncType) bool {
	if funcType == nil {
		pos := fset.Position(funcType.Pos())
		log(slog.LevelError, "is not a valid function",
			slog.String("info", fmt.Sprintf("%s:%d:%d %s.%s",
				fileName, pos.Line, pos.Column, serviceName, methodName),
			))

		return false
	}

	if funcType.Params == nil {
		pos := fset.Position(funcType.Pos())
		log(slog.LevelError, "has no parameters",
			slog.String("info", fmt.Sprintf("%s:%d:%d %s.%s",
				fileName, pos.Line, pos.Column, serviceName, methodName),
			))

		return false
	}

	if len(funcType.Params.List) != 2 {
		pos := fset.Position(funcType.Pos())
		log(slog.LevelError, "does not have exactly two parameters",
			slog.String("info", fmt.Sprintf("%s:%d:%d %s.%s",
				fileName, pos.Line, pos.Column, serviceName, methodName),
			))
		return false
	}

	if _, ok := funcType.Params.List[0].Type.(*ast.StarExpr); !ok {
		pos := fset.Position(funcType.Params.List[0].Pos())
		log(slog.LevelError, "first parameter must be a pointer",
			slog.String("info", fmt.Sprintf("%s:%d:%d %s.%s",
				fileName, pos.Line, pos.Column, serviceName, methodName),
			))
		return false
	}

	if _, ok := funcType.Params.List[1].Type.(*ast.StarExpr); !ok {
		pos := fset.Position(funcType.Params.List[1].Pos())
		log(slog.LevelError, "second parameter must be a pointer",
			slog.String("info", fmt.Sprintf("%s:%d:%d %s.%s",
				fileName, pos.Line, pos.Column, serviceName, methodName),
			))
		return false
	}

	if funcType.Results == nil {
		pos := fset.Position(funcType.Pos())
		log(slog.LevelError, "has no return values",
			slog.String("info", fmt.Sprintf("%s:%d:%d %s.%s",
				fileName, pos.Line, pos.Column, serviceName, methodName),
			))

		return false
	}

	if len(funcType.Results.List) != 1 {
		pos := fset.Position(funcType.Pos())

		log(slog.LevelError, "method does not have exactly two return values",
			slog.String("info", fmt.Sprintf("%s:%d:%d %s.%s",
				fileName, pos.Line, pos.Column, serviceName, methodName),
			))
		return false
	}

	errRespIdent, ok := funcType.Results.List[0].Type.(*ast.Ident)
	if !ok {
		pos := fset.Position(funcType.Results.List[0].Pos())
		log(slog.LevelError, "first return value is not valid",
			slog.String("info", fmt.Sprintf("%s:%d:%d %s.%s",
				fileName, pos.Line, pos.Column, serviceName, methodName),
			))

		return false
	}

	if errRespIdent.Name != "error" {
		pos := fset.Position(funcType.Results.List[1].Pos())
		log(slog.LevelError, "second return value is not error",
			slog.String("info", fmt.Sprintf("%s:%d:%d %s.%s",
				fileName, pos.Line, pos.Column, serviceName, methodName),
			))

		return false
	}

	return true
}

func extractMethods(fset *token.FileSet, fileName, serviceName string, interfaceType *ast.InterfaceType) []Method {
	var methods []Method

	for _, method := range interfaceType.Methods.List {
		if funcType, ok := method.Type.(*ast.FuncType); ok {
			if !validateMethodSignature(fset, fileName, serviceName, method.Names[0].Name, funcType) {
				continue
			}

			methodName := method.Names[0].Name

			requestType := extractTypeName(funcType.Params.List[0].Type)
			responseType := extractTypeName(funcType.Params.List[1].Type)

			// Remove pointer prefix from response type
			requestType = strings.TrimPrefix(requestType, "*")
			responseType = strings.TrimPrefix(responseType, "*")

			methods = append(methods, Method{
				Name:         methodName,
				RequestType:  requestType,
				ResponseType: responseType,
			})
		}
	}

	return methods
}

func generateClientCode(temp *template.Template, serviceData ServiceData) error {
	buf := new(bytes.Buffer)
	if err := temp.Execute(buf, serviceData); err != nil {
		return fmt.Errorf("error executing template: %w", err)
	}

	formatted, err := imports.Process("", buf.Bytes(), nil)
	if err != nil {
		return fmt.Errorf("imports error: %w", err)
	}

	fileName := fmt.Sprintf("%s_client_gen.go", strings.ToLower(serviceData.ServiceName))
	file, err := os.Create(fileName)
	if err != nil {
		return fmt.Errorf("error creating file %s: %w", fileName, err)
	}
	defer func() { _ = file.Close() }()

	if _, err := file.Write(formatted); err != nil {
		return fmt.Errorf("error writing to file %s: %w", fileName, err)
	}

	return nil
}

func main() {
	flag.Parse()

	if *input == "" {
		slog.Error("Input package directory is required. Use -input flag to specify it.")
		os.Exit(1)
	}

	cfg := &packages.Config{
		Mode: packages.NeedName |
			packages.NeedFiles |
			packages.NeedTypes |
			packages.NeedTypesInfo |
			packages.NeedSyntax |
			packages.NeedImports |
			packages.NeedDeps,
	}
	pkgs, err := packages.Load(cfg, *input)
	if err != nil {
		slog.Error(err.Error())
		os.Exit(1)
	}

	var serviceDatas []ServiceData

	for _, pkg := range pkgs {
		if len(pkg.Errors) > 0 {
			for _, pkgErr := range pkg.Errors {
				log(slog.LevelError, "Package load error", slog.String("error", pkgErr.Error()))
			}

			continue
		}

		log(slog.LevelInfo, "Processing package", slog.String("package", pkg.PkgPath))

		for _, file := range pkg.Syntax {
			fileName := pkg.Fset.Position(file.Pos()).Filename
			if strings.Contains(fileName, "_test.go") || strings.Contains(fileName, "_gen.go") {
				continue
			}

			log(slog.LevelInfo, "Processing file", slog.String("file", fileName))

			ast.Inspect(file, func(n ast.Node) bool {
				if typeSpec, ok := n.(*ast.TypeSpec); ok {
					if interfaceType, ok := typeSpec.Type.(*ast.InterfaceType); ok {
						serviceName := typeSpec.Name.Name
						log(slog.LevelInfo, "Found interface", slog.String("name", serviceName))

						// Extract methods from interface
						methods := extractMethods(pkg.Fset, fileName, serviceName, interfaceType)

						serviceDatas = append(serviceDatas, ServiceData{
							PackageName: pkg.Name,
							ServiceName: serviceName,
							Methods:     methods,
						})
					}
				}

				return true
			})
		}
	}

	temp := template.New("clientTemplate")
	temp, err = temp.Parse(clientTemplate)
	if err != nil {
		slog.Error("Error parsing template", slog.String("error", err.Error()))
		os.Exit(1)
	}

	for _, serviceData := range serviceDatas {
		// log("Generating client for service: %s\n", serviceData.ServiceName)

		if err := generateClientCode(temp, serviceData); err != nil {
			slog.Error("Error generating client code", slog.String("error", err.Error()))
			os.Exit(1)
		}

		// log("Client code generated successfully for service: %s\n", serviceData.ServiceName)
	}
}
